\documentclass[english]{article}


\usepackage{graphicx}
\usepackage{grffile}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{hyperref}

\setcounter{secnumdepth}{4}



\title{\scshape\Large Team members}
\author{
	NG Maluleke\\
	\texttt{13229908}
	\and
	D Mulugisi\\
	\texttt{13071603}
	\and
	C Nel\\
	\texttt{14029368}
	\and
	LE Tom\\
	\texttt{13325095}
}


\graphicspath{{Pictures/}}

\begin{document}

	
	\begin{figure}
		\includegraphics[width=\linewidth]{up_logo.png}
	\end{figure}
	
	\begin{center}
	 \line(1,0){370}
	\\[0.2cm]
    {\scshape\Large Testing Document \par}
	\vspace{0.1cm}
	\line(1,0){370}
	\\[0.8cm]
	
	{\scshape\large Project name: Arcane Arcade\par}	
	\vspace{1cm}
	{\scshape\large Client: Tony vd Linden\par}
	\vspace{1cm}
	{\scshape\large Team name: Terabites\par}
	\vspace{1cm}
	{\let\newpage\relax\maketitle}
	\end{center}
	
	
	\pagenumbering{gobble}
	\newpage
	\tableofcontents

	\pagenumbering{arabic}
	\newpage
	
	\section{Introduction}
		 The project is called \textit{Arcane Arcade}, which references the esoteric language users will have to use, as well as the gamification approach to try and make it as fun as possible.

	
		
		\subsection{Purpose}
			
			This documentation is the testing documentation for Arcane Arcade project. It outlines the entire testing plan and its documentation process. The documentation firstly establishes the scope, thereafter the testing environment is discussed including all the relevant assumptions and dependencies made during the testing process.\\
			Unit testing is a crucial part of a continual software development approach and is necessary to ensure that all components properly work before integrating them into the system. The system is used by employers to determine the level of skills and classification of potential employees and based on those skills they placed on appropriate positions within the company.
			
		\subsection{Scope}
		\subsection{Test Environment}
		
		\begin{itemize}
			\item Programming Languages\\
			 Java SE standard and ANTLR4 were used for backend development of the system and angular js and HTML was used on the frontend of the system. \\
			
			\item Testing Frameworks\\
			The tests are JUnit tests and are running under JUnit 4.12. Junit was chosen because it can be used separately or integrated with build tools like Maven and Ant and third party extensions.
			
			\item Coding Environment\\
			Netbeans and IntelliJ IDEs that we chose for the project development. Maven sets up the environment by providing all the needed dependencies which are included in the POM file.\\
			
			\item Operating System\\
			The tests are independent of the operating system and occur under Maven.\\
			
			\item Internet Browsers\\
			The web-interface was tested to execute accurately on GOOGLE Chrome, Mozilla Firefox and Internet Explorer web browser.\\
		\end{itemize}
	
		\subsection{Assumptions and Dependencies}
		Most of the unit testing is to test the compiler component of the system. The compiler consists of a lexer, parser, and visitor. The lexer and parser are automatically generated by ANTLR4 using a specified grammar file which specifies the lexer and syntax rules for the language. The visitor is manually implemented and is in charge of walking the parse tree in the correct order and executing the appropriate commands on each node.

			Testing is done through JUnit test files and Maven automatically running the tests when deploying the project or running the \textit{test} command through Maven.
			
			\newpage
					\section*{Unit Test Plan}

		\section{Test Items}
			The lexer and parser are tested together by feeding a list with a syntatically correct and wrong statements in the implemented language. The lexer then tokenizes the input whereafter the parser parses the token stream and builds a parse tree. It is then tested that the parser reports the correct symantic errors.
			
			The visitor is tested by having it run through a list of statements. The visitor is implemented in such a way that it holds a list of values that need to be printed. The test then simply looks at this list in the visitor object and compares it with a list of expected results.
		
	\section{Functional Features to be Tested}
		\vspace{0.8cm}

		\section{Test Cases}
	\vspace{0.4cm}

			\subsection{Test Case 1: Syntax Testing} 
						\includegraphics[width=\linewidth]{test1.jpg}

			\subsubsection{Condition 1: The back-end server must be running } 
			\paragraph{Objective :} The main objective of this test is to validate whether the syntax of the user input is correct.
			\paragraph{Input :} For every use case, both valid and invalid entries will be construcuted to ensure that exceptions are raised if pre-condiions are not met. Further all return values are checked to ensure that the returned object is correct according the stated
			functional requirements. In this case a string of user  esolang input expression will be our input.
			
			\paragraph{Outcome :}All use cases should fulfill their stated service contract by returning the appropriate response object  which was outlined on the functional requirements.\\
			
		
			 
			
			\subsection{Test Case 2: Testing Declaration and Conditions} 
						\includegraphics[width=\linewidth]{test2.jpg}

			\subsubsection{Condition 1: The back-end server must be running }
			\paragraph{Objective :} 
			The purpose of this test is to validate that all the declared variables are initialized with valid values
			\paragraph{Input :}
			Both valid and invalid entries will be construcuted to ensure that exceptions are raised if pre-condiions are not met. Further all return values are checked to ensure that the returned object is correct according the stated
			functional requirements. In this case a string of user  esolang input expression will be our input.
			\paragraph{Outcome :} On failure this test will raise a deceleration failed exception while on a pass the test return the  appropriate response object  which was outlined on the functional requirements  \\
			\\[12pt]	
			
			\subsection{Test Case 3: Expressions Testing} 
						\includegraphics[width=\linewidth]{test3.jpg}

			\subsubsection{Condition 1: The back-end server must be running}
			\paragraph{Objective :}The purpose of this test is to validate whether the expression contains valid tokens. An expressions which is ran in the esolang is also ran in java code and the end results of the two same but differently executed methods are compared for equality through the assert methods.
			\paragraph{Input :} Both valid and invalid entries will be construcuted to ensure that exceptions are raised if pre-conditions are not met.
			\paragraph{Outcome :} Upon recognizing an invalid token the test raises an exception and if no invalid token is found, the test returns the  appropriate response object  which was outlined on the functional requirements.  \\
			
				\subsection{Test Case 4: Assignment statements testing} 
				\includegraphics[width=\linewidth]{assignment.png}
				
				\subsubsection{Condition 1: The back-end server must be running } 
				\subsubsection{Condition 2: All variables on the assignment statement must be initialized with valid values } 
				\paragraph{Objective :} The main objective of the following test is to validate whether the assignment operator of our esolang language produces the expected results, that is assigns the correct values to declared variables.
				\paragraph{Input :} For every use case, both valid and invalid entries will be construcuted to ensure that exceptions are raised if pre-condiions are not met. Further all return values are checked to ensure that the returned object is correct according the stated
				functional requirements. In this case a string of user  esolang input expression will be our input.
				
				\paragraph{Outcome :}The test case returns a boolean value which state whether the assignment was valid or not and if invalid an assert function is used to terminate the test with a fail\\
				
				\subsection{Test Case 4: Assignment statements testing} 
				\includegraphics[width=\linewidth]{wrong.png}
				
				\subsubsection{Condition 1: The back-end server must be running } 
				\subsubsection{Condition 2: All variables on the assignment statement must be initialized with valid values } 
				\paragraph{Objective :} The main objective of the following test is to validate whether a given expression produces the correct results after compiling it with the compiler.
				\paragraph{Input :} For every use case, both valid and invalid entries will be construcuted to ensure that exceptions are raised if pre-condiions are not met. Further all return values are checked to ensure that the returned object is correct according the stated
				functional requirements. In this case a string of user  esolang input expression will be our input.
				
				\paragraph{Outcome :}An assert function is used based on the results of the test. if the test is not succesfull we terminate the function with a fail \\
				
		 	
	\newpage
		   \section{Pass/Fail Criteria}
		   For every use case tested, the following criteria must be met for the test to be
		   considered a \textbf{Pass}.
		   \begin{itemize}
		   	\item All pre-conditions should be fulfilled. If not, an appropriate execption
		   	must be raised as to alert the client.
		   	\item All post-condtions must hold upon returning from the function call. If 
		   	a post condition doesn't hold, the test will fail.
		   	\item Any stated functionality specific to the use case as set out in the
		   	functional requirements document must be validated within the unit test to
		   	ensure stated functionality is implemented.
		   \end{itemize}
	
		\newpage
		\section*{Unit Test Report}

		\section{Detailed Test Results}
		\subsection{Overview of Test Results}

All the test cases passed. The tests were supposed to pass to prove that everything is working properly as expected. The tests were from the jUnit framework.\\

We selected jUnit because of simplicity to use and how it stays updated. jUnit was also easy to include into maven so that all tests are executed automatically every time the project is built. Executing the tests is then greatly simplified and changes can be tracked by observing changes in the test results.
		\subsection{Functional Requirements Test Results}
		The tests we have created for this module are contained within the file \href{https://github.com/Dzilafho/TeraBites/tree/master/Arcane%20Arcade%20Integrated/ArcaneArcade/src/test/java/com/mycompany/arcane/EsoLangBaseVisitorImpTest.java}{EsoLangBaseVisitorImpTest.java} from \href{https://github.com/Dzilafho/TeraBites}{TeraBites}.
		
			\subsubsection{Test Case 1: Syntax}
			\begin{itemize}
			\item The first proper/wrong context passed the test, there were no exceptions.\\
			
			\item An error was displayed to indicated that the syntax is not correct\\
			\end{itemize}
						\paragraph{Result: } Pass.

			\subsubsection{Test Case 2: Declarations and Conditions}
			\begin{itemize}
			\item The values were assigned to the variables\\
			
			\item Certain statements did not execute because the conditions were unmet\\
			\end{itemize}
						\paragraph{Result: } Pass.

			\subsubsection{Test Case 3: Expression Testing}
			\begin{itemize}
			\item Mathematical operations can be done\\
			
			\item Language features are recognized and excuted\\
			\end{itemize}
						\paragraph{Result: } Pass.

		\section{Other}
		\section{Conclusions and Recommendations}
		The body of our tests re-use the same variables which can have a negative effect on our testing as values get altered before the test so to combat this we used jUnit @BeforeClass and @After annotations to prepare the environment for accurate testing and to make sure that each executions begins with the appropriate criteria.
		\\[4pt]
		Exit criteria are observed and compared immediately before all test functions exit. Here the effects of the of the statements are compared and asserted as the expected values.
		\end{document}

	
