\documentclass[english]{article}


\usepackage{graphicx}
\usepackage{grffile}
\usepackage[T1]{fontenc}
\usepackage{babel}



\title{\scshape\Large Team members}
\author{
	NG Maluleke\\
	\texttt{13229908}
	\and
	D Mulugisi\\
	\texttt{13071603}
	\and
	C Nel\\
	\texttt{14029368}
	\and
	LE Tom\\
	\texttt{13325095}
}


\graphicspath{{Pictures/}}

\begin{document}

	
	\begin{figure}
		\includegraphics[width=\linewidth]{up_logo.png}
	\end{figure}
	
	\begin{center}
	 \line(1,0){370}
	\\[0.2cm]
    {\scshape\Large Testing Document \par}
	\vspace{0.1cm}
	\line(1,0){370}
	\\[0.8cm]
	
	{\scshape\large Project name: Arcane Arcade\par}	
	\vspace{1cm}
	{\scshape\large Client: Tony vd Linden\par}
	\vspace{1cm}
	{\scshape\large Team name: Terabites\par}
	\vspace{1cm}
	{\let\newpage\relax\maketitle}
	\end{center}
	
	
	\pagenumbering{gobble}
	\newpage
	\tableofcontents

	\pagenumbering{arabic}
	\newpage
	
	\section{Introduction}
		 The project is called \textit{Arcane Arcade}, which references the esoteric language users will have to use, as well as the gamification approach to try and make it as fun as possible.

	
		
		\subsection{Purpose}
			
			This documentation is the testing documentation for Arcane Arcade project. It outlines the entire testing plan and its documentation process. The documentation firstly establishes the scope, thereafter the testing environment is discussed including all the relevant assumptions and dependencies made during the testing process.\\
			Unit testing is a crucial part of a continual software development approach and is necessary to ensure that all components properly work before integrating them into the system. The system is used by employers to determine the level of skills and classification of potential employees and based on those skills they placed on appropriate positions within the company.
			
		\subsection{Scope}
		\subsection{Test Environment}
		
		\begin{itemize}
			\item Programming Languages\\
			 Java SE standard and ANTLR4 were used for backend development of the system and angular js and HTML was used on the frontend of the system. \\
			
			\item Testing Frameworks\\
			The tests are JUnit tests and are running under JUnit 4.12. Junit was chosen because it can be used separately or integrated with build tools like Maven and Ant and third party extensions.
			
			\item Coding Environment\\
			Netbeans and IntelliJ IDEs that we chose for the project development. Maven sets up the environment by providing all the needed dependencies which are included in the POM file.\\
			
			\item Operating System\\
			The tests are independent of the operating system and occur under Maven.\\
			
			\item Internet Browsers\\
			The web-interface was tested to execute accurately on GOOGLE Chrome, Mozilla Firefox and Internet Explorer web browser.\\
		\end{itemize}
	
		\subsection{Assumptions and Dependencies}
		Most of the unit testing is to test the compiler component of the system. The compiler consists of a lexer, parser, and visitor. The lexer and parser are automatically generated by ANTLR4 using a specified grammar file which specifies the lexer and syntax rules for the language. The visitor is manually implemented and is in charge of walking the parse tree in the correct order and executing the appropriate commands on each node.

			Testing is done through JUnit test files and Maven automatically running the tests when deploying the project or running the \textit{test} command through Maven.
		\section{Test Items}
			The lexer and parser are tested together by feeding a list with a syntatically correct and wrong statements in the implemented language. The lexer then tokenizes the input whereafter the parser parses the token stream and builds a parse tree. It is then tested that the parser reports the correct symantic errors.
			
			The visitor is tested by having it run through a list of statements. The visitor is implemented in such a way that it holds a list of values that need to be printed. The test then simply looks at this list in the visitor object and compares it with a list of expected results.
		
	\section{Functional Features to be Tested}
		\section{Test Cases}

			\subsection{Test Case 1: Language Features}
			\includegraphics[width=\linewidth]{test1.jpg}
			\\[12pt]
			The two above above methods annotated with the @Before and the @BeforeClass prepare the test environment for the next test methods by executing and restoring the states prerior to running another test. 
			\subsection{Test Case 2: Testing Declaration and Conditions}
			\includegraphics[width=\linewidth]{test2.jpg}
			\\[12pt]	
			Here we test to see if the assignments under declarations and working properly and if conditional statements are functioning as expected.
			To test if the methods are functioning as expected, we compare values from the methods and the values that	we expect to find via the assert() method.	
			\subsection{Test Case 3: Testing Expressions}			
			\includegraphics[width=\linewidth]{test3.jpg}
			\\[12pt]		
			An expressions which is ran in the esolang is also ran in java code and the end results of the two same but differently executed methods are compared for equality through the assert methods. 	
			\subsection{Test Case 4: Testing Assignment and Comparison}
			\includegraphics[width=\linewidth]{test4.jpg}
			\\[12pt]
			We test assignment and comparison by comparing expected values with the values we get from the esoteric language.	
	
	\section{Execution Strategy}
	\section{Item Pass/Fail Criteria}
	
	\newpage
	\title{Unit Test Report}
\section{Detailed Test Results}
\subsection{Overview of Test Results}
\subsection{Functional Requirements Test Results}
	\subsubsection{Authentication Module}
	\subsubsection{User Management Module}
	\subsubsection{Challenge Management Module}
		\section{Conclusions and Recommendations}
		The body of our tests re-use the same variables which can have a negative effect on our testing as values get altered before the test so to combat this we used jUnit @BeforeClass and @After annotations to prepare the environment for accurate testing and to make sure that each executions begins with the appropriate criteria.
		\\[4pt]
		Exit criteria are observed and compared immediately before all test functions exit. Here the effects of the of the statements are compared and asserted as the expected values.
		\end{document}

	
