\documentclass[english]{article}


\usepackage{graphicx}
\usepackage{grffile}
\usepackage[T1]{fontenc}
\usepackage{babel}



\title{\scshape\Large Team members}
\author{
	NG Maluleke\\
	\texttt{13229908}
	\and
	D Mulugisi\\
	\texttt{13071603}
	\and
	C Nel\\
	\texttt{14029368}
	\and
	LE Tom\\
	\texttt{13325095}
}


\graphicspath{{Pictures/}}

\begin{document}

	
	\begin{figure}
		\includegraphics[width=\linewidth]{up_logo.png}
	\end{figure}
	
	\begin{center}
	 \line(1,0){370}
	\\[0.2cm]
    {\scshape\Large Testing Document \par}
	\vspace{0.1cm}
	\line(1,0){370}
	\\[0.8cm]
	
	{\scshape\large Project name: Arcane Arcade\par}	
	\vspace{1cm}
	{\scshape\large Client: Tony vd Linden\par}
	\vspace{1cm}
	{\scshape\large Team name: Terabites\par}
	\vspace{1cm}
	{\let\newpage\relax\maketitle}
	\end{center}
	
	
	\pagenumbering{gobble}
	\newpage
	\tableofcontents

	\pagenumbering{arabic}
	\newpage
	
	\section{Introduction}
		 The project is called \textit{Arcane Arcade}, which references the esoteric language users will have to use, as well as the gamification approach to try and make it as fun as possible.

	\section{Background}
		The client needs a way to test potential new employees without running the risk of tests being leaked and without having to manually create complicated in-house tests. Through this system the client can test potential
		new employees via a custom programming language, an esoteric language, while keeping the tests interesting through the use of gamification principles. Testees' performance and use of help can also help determine the
		ideal employment position.
		
	\section{Testing}
		\subsection{Introduction}
			Unit testing is a crucial part of a continual software development approach and is necessary to ensure that all components properly work before integrating them into the system.
		\subsection{Approach}
			Most of the unit testing is to test the compiler component of the system. The compiler consists of a lexer, parser, and visitor. The lexer and parser are automatically generated by ANTLR4 using a specified grammar file which specifies the lexer and syntax rules for the language. The visitor is manually implemented and is in charge of walking the parse tree in the correct order and executing the appropriate commands on each node.
			
			Testing is done through JUnit test files and Maven automatically running the tests when deploying the project or running the \textit{test} command through Maven.
		\subsection{Tests conducted}
			The lexer and parser are tested together by feeding a list with a syntatically correct and wrong statements in the implemented language. The lexer then tokenizes the input whereafter the parser parses the token stream and builds a parse tree. It is then tested that the parser reports the correct symantic errors.
			
			The visitor is tested by having it run through a list of statements. The visitor is implemented in such a way that it holds a list of values that need to be printed. The test then simply looks at this list in the visitor object and compares it with a list of expected results.
		
	\section{Testing Strategy}
		\subsection{System Test}
		\subsection{Performance Test}
		\subsection{Security Test}
		\subsection{Automated Test}
		\subsection{Stress and Volume Test}
	
	\section{Execution Strategy}
		\subsection{Entry and Exit Criteria}
		\subsection{Test Cycles}
		\subsection{Dependencies}
			\subsubsection{Hardware}
			\subsubsection{Software}
			\subsubsection{Data}
			
	\section{Test Management Procedures}
		\subsection{Result Reviews}
		\subsection{Defect Reporting}
		\subsection{Change Reporting}
		
	\section{Test Environment}
		
\end{document}
