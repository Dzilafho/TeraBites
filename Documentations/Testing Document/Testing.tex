\documentclass[english]{article}


\usepackage{graphicx}
\usepackage{grffile}
\usepackage[T1]{fontenc}
\usepackage{babel}



\title{\scshape\Large Team members}
\author{
	NG Maluleke\\
	\texttt{13229908}
	\and
	D Mulugisi\\
	\texttt{13071603}
	\and
	C Nel\\
	\texttt{14029368}
	\and
	LE Tom\\
	\texttt{13325095}
}


\graphicspath{{Pictures/}}

\begin{document}

	
	\begin{figure}
		\includegraphics[width=\linewidth]{up_logo.png}
	\end{figure}
	
	\begin{center}
	 \line(1,0){370}
	\\[0.2cm]
    {\scshape\Large Testing Document \par}
	\vspace{0.1cm}
	\line(1,0){370}
	\\[0.8cm]
	
	{\scshape\large Project name: Arcane Arcade\par}	
	\vspace{1cm}
	{\scshape\large Client: Tony vd Linden\par}
	\vspace{1cm}
	{\scshape\large Team name: Terabites\par}
	\vspace{1cm}
	{\let\newpage\relax\maketitle}
	\end{center}
	
	
	\pagenumbering{gobble}
	\newpage
	\tableofcontents

	\pagenumbering{arabic}
	\newpage
	
	\section{Introduction}
		 The project is called \textit{Arcane Arcade}, which references the esoteric language users will have to use, as well as the gamification approach to try and make it as fun as possible.

	\section{Background}
		The client needs a way to test potential new employees without running the risk of tests being leaked and without having to manually create complicated in-house tests. Through this system the client can test potential
		new employees via a custom programming language, an esoteric language, while keeping the tests interesting through the use of gamification principles. Testees' performance and use of help can also help determine the
		ideal employment position.
		
	\section{Testing}
		\subsection{Introduction}
			Unit testing is a crucial part of a continual software development approach and is necessary to ensure that all components properly work before integrating them into the system.
		\subsection{Approach}
			Most of the unit testing is to test the compiler component of the system. The compiler consists of a lexer, parser, and visitor. The lexer and parser are automatically generated by ANTLR4 using a specified grammar file which specifies the lexer and syntax rules for the language. The visitor is manually implemented and is in charge of walking the parse tree in the correct order and executing the appropriate commands on each node.
			
			Testing is done through JUnit test files and Maven automatically running the tests when deploying the project or running the \textit{test} command through Maven.
		\subsection{Tests conducted}
			The lexer and parser are tested together by feeding a list with a syntatically correct and wrong statements in the implemented language. The lexer then tokenizes the input whereafter the parser parses the token stream and builds a parse tree. It is then tested that the parser reports the correct symantic errors.
			
			The visitor is tested by having it run through a list of statements. The visitor is implemented in such a way that it holds a list of values that need to be printed. The test then simply looks at this list in the visitor object and compares it with a list of expected results.
		
	\section{Testing Strategy}
		\subsection{Base Vistor Implentation Test}
			\includegraphics[width=\linewidth]{test1.jpg}
			\\[12pt]
			The two above above methods annotated with the @Before and the @BeforeClass prepare the test environment for the next test methods by executing and restoring the states prerior to running another test. 
			\subsection{}
			\includegraphics[width=\linewidth]{test2.jpg}
			\\[12pt]	
			Here we test to see if the assignments under declarations and working properly and if conditional statements are functioning as expected.
			To test if the methods are functioning as expected, we compare values from the methods and the values that	we expect to find via the assert() method.	
			\subsection{}			
			\includegraphics[width=\linewidth]{test3.jpg}
			\\[12pt]		
			An expressions which is ran in the esolang is also ran in java code and the end results of the two same but differently executed methods are compared for equality through the assert methods. 	
			\subsection{}
			\includegraphics[width=\linewidth]{test4.jpg}
			\\[12pt]
			We test assignment and comparison by comparing expected values with the values we get from the esoteric language.	
	
	\section{Execution Strategy}
		\subsection{Entry and Exit Criteria}
		The body of our tests re-use the same variables which can have a negative effect on our testing as values get altered before the test so to combat this we used jUnit @BeforeClass and @After annotations to prepare the environment for accurate testing and to make sure that each executions begins with the appropriate criteria.
		\\[4pt]
		Exit criteria are observed and compared immediately before all test functions exit. Here the effects of the of the statements are compared and asserted as the expected values.
		
	\section{Test Environment}
	The tests are independent of the operating system and occur under Maven. The environment setup of the tests is the inclusion and import of the used frameworks. The tests are jUnit tests and are running under jUnit 4.12. Maven sets up the environment by providing all the needed dependencies which are included in the POM file.
\end{document}
